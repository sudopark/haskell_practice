


addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

-- Int는 정수
-- Integer는 더 큰 정수
factorial :: Integer -> Integer
factorial n = product [1..n]

-- float는 하나의 소수점을 지님
circumference :: Float -> Float
circumference r = 2 * pi * r

-- Double은 정밀도가 더 높은 부동소소점(두배의 비트 사용)
circumference' :: Double -> Double
circumference' r = 2 * pi * r

-- Bool은 불리언 타입
-- Char는 유니코드 문자에 해당
-- Tuple 요소에 타입에 따라 정해짐 빈 튜플에서 최대 62개의 요소를 지닌 튜플 가능

----------------------------------------------------------------
-- 타입 변수
-- :t head
-- head: [a] -> a
-- 여기서 a는 타입 변수(type variable)을 의미, 모든 타입이 될 수 있음을 뜻함
-- 제네릭과 비슷하고 함수는 타입 변수를 통하여 타입-안전(type-safe) 방식에서 동작할 수 있음
-- 타입 변수를 이용하는 함수를 **다형성 함구(polymorphic function)** 이라 함
-- head의 경우: 모든 타입의 리스트를 받아 그 첫번째 항목을 반환함을 의미
-- :t fst
-- fst :: (a, b) -> a

----------------------------------------------------------------
-- 타입 클래스 type class
-- type class는 어떤 동작을 정의하는 인터페이스, 어떤 타입이 특정 타입 클래스의 인스턴스라면 이는
-- 타입 클래스가 기술한 동작을 지원하며 구현한다를 의미
-- 타입 클래스에는 많은 함수가 지정하며, 어떤 타입을 인스턴스로 만들때 그 타입으로 함수들이 정의됨

-- 항등 연산자 예제
-- 항등 연산자의 타입 시그니처
-- :t (==)
-- (==) :: (Eq a) => a => a => Bool
-- => 앞에 위치하는것은 클래스 제약(class constraint): 두 값의 타입(a)는 Eq 클래스의 인스턴스 이여야 함을 의미
-- ** 타입 클래스는 객체지향 프로그래밍에서의 클래스와는 다름

----------------------------------------------------------------
-- 일반적인 하스켈 타입 클래스
-- Eq 타입 클래스: 타입이 같은지 판단, ==, /= 함수로 인스턴스가 구현됨

-- Ord 타입 클래스: comparable 같은거, >, <, >=, <= 포함
-- compare 함수는 ord 인스턴스가 타입인 두개의 값을 받아 Ordering을 반환
-- Ordering은 GT(보다큼), LT(보다 작음)인 Eq가 될 수 있다.
cmp = 5 `compare` 3 -- GT

-- Show 타입 클래스: 인스턴스 값들을 문자열로 표시, show 함수

-- Read 타입 클래스: show와 반대의 케이스, 하나의 문자열을 받아 타입이 read의 인스턴스인 값을 반환
-- :t read
-- read :: (Read a) => String -> a
r1 = read "True" || False -- True
r2 = read "7.3" + 3.3     -- 10.6
-- 근데 만약 read "4" 까지만 입력하면? -> 타입추론 실패
-- type annotation을 이용하여 이를 해결 가능 -> 명시적으로 타입을 알려줌, 마지막에 ::[type]
-- 하스켈은 정적타입 언어이기 때문에 코드 컴파일 이전에 타입을 알아야함
r3 = read "3" :: Int

-- Enum 타입 클래스
-- 열거할 수 있는 값을 의미, successor와 predecessor가 정의됨
-- 대부분의 숫자형 타입

-- Bounded 타입 클래스
-- minBound, maxBound로 상한, 하한을 표시, (Boudned a) => a 타입을 지니는 다형성 함수
-- 모든 구성요서가 Bounded의 인스턴스인 튜플 역시 Boudned의 인스턴스로 간주

-- Num 타입 클래스
-- 이것의 인스턴스는 숫자처럼 동작 가능
-- :t 20
-- 20 :: (Num t) => t     -> 다형성 함수
-- * 연산자 예제
-- :t (*)
-- (*) :: (Num a) => a -> a -> a
-- Num의 인스턴스가 되려면 Show와 Eq의 인스턴스를 따러야 한다.

-- Floating 타입 클래스: 부동소수점

-- Integral 타입 클래스: 정수형
-- fromIntegral :: (Num n, Integral a) => a -> m  -- 정수를 넘버로 변환

----------------------------------------------------------------
-- 결론: 타입 클래스는 추상 인터페이스를 제공하기 때문에 하나의 타입이 여러가지 타입 클래스들의 인스턴스가 될 수 있음
-- 타입클래스 간에 계층구조, 전제조건이 필요한 경우가 있다: Ord는 Eq이여야 한다.
